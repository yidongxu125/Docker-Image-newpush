name: 04. 单项同步 (To GHCR)
env:
  WEBHOOK_URL: ${{ secrets.WEBHOOK_URL }}
  REGISTRY: ghcr.io
  # 映射 Secret 到 Env 以供 if 判断
  DOCKERHUB_USER: ${{ secrets.DOCKERHUB_USERNAME }}

on:
  workflow_dispatch:
    inputs:
      image_name:
        description: "原镜像名称 (例如: mysql:8.0)"
        required: true
        default: "nginx:alpine"
      target_name:
        description: "保存名称 (留空则自动处理)"
        required: false
      platform:
        description: "指定架构 (例如: linux/arm64，留空默认 amd64)"
        required: false
        default: ""
      force_sync:
        description: "强制同步 (跳过摘要比对)"
        type: boolean
        required: false
        default: false
      clean_disk:
        description: "清理磁盘空间 (减少空间不足风险，但耗时增加)"
        type: boolean
        required: false
        default: false

jobs:
  mirror:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write # 必须权限

    steps:
      # 1. 空间清理 (防止大镜像爆盘)
      - name: 🗑️ 清理磁盘空间
        uses: easimon/maximize-build-space@master
        if: ${{ inputs.clean_disk == true }}
        with:
          root-reserve-mb: 2048
          swap-size-mb: 128
          remove-dotnet: "true"
          remove-android: "true"
          remove-haskell: "true"
          build-mount-path: "/var/lib/docker/"

      - name: 重启 Docker
        run: sudo service docker restart

      - name: 登录 DockerHub
        if: env.DOCKERHUB_USER != ''
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
        continue-on-error: true

      - name: 登录 GHCR
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: 拉取、重命名并推送
        env:
          INPUT_IMAGE: ${{ inputs.image_name }}
          INPUT_TARGET: ${{ inputs.target_name }}
          INPUT_PLATFORM: ${{ inputs.platform }}
          INPUT_FORCE: ${{ inputs.force_sync }}
        run: |
          # Define retry function
          # Define retry function
          function retry {
            local n=1
            local max=3
            local delay=5
            while true; do
              "$@" && break || {
                if [[ $n -lt $max ]]; then
                  ((n++))
                  echo "⚠️ Command failed. Attempt $n/$max:" >&2
                  sleep $delay;
                else
                  echo "❌ The command has failed after $max attempts." >&2
                  return 1
                fi
              }
            done
          }

          # --- 1. 变量准备 ---
          SRC_IMAGE="$INPUT_IMAGE"
          PLATFORM_ARG=""

          # 默认架构参数
          SKOPEO_OS="linux"
          SKOPEO_ARCH="amd64"

          if [ -n "$INPUT_PLATFORM" ]; then
            PLATFORM_ARG="--platform $INPUT_PLATFORM"
            echo "⚙️ 指定架构: $INPUT_PLATFORM"
            
            # 解析 platform
            if [[ "$INPUT_PLATFORM" == *"/"* ]]; then
               SKOPEO_OS=$(echo "$INPUT_PLATFORM" | awk -F'/' '{print $1}')
               SKOPEO_ARCH=$(echo "$INPUT_PLATFORM" | awk -F'/' '{print $2}')
            else
               SKOPEO_ARCH="$INPUT_PLATFORM"
            fi
          fi

          # 构造 Skopeo 参数
          SKOPEO_FLAGS="--override-os $SKOPEO_OS --override-arch $SKOPEO_ARCH"

          # --- 2. 目标名称计算 (智能前缀) ---
          if [ -n "$INPUT_TARGET" ]; then
            TARGET_TAG="$INPUT_TARGET"
          else
             SCOPE=$(echo "$SRC_IMAGE" | awk -F'/' '{if (NF>2) print $(NF-1); else if (NF==2 && $1!="library") print $1; else print ""}')
             BASE_NAME=$(echo "$SRC_IMAGE" | awk -F'/' '{print $NF}')
             
             if [ -n "$SCOPE" ]; then
                TARGET_TAG="${SCOPE}_${BASE_NAME}"
             else
                TARGET_TAG="${BASE_NAME}"
             fi
             
             if [ -n "$INPUT_PLATFORM" ]; then
                PLAT_PREFIX=$(echo "$INPUT_PLATFORM" | sed 's/\//_/g')
                TARGET_TAG="${PLAT_PREFIX}_${TARGET_TAG}"
             fi
          fi

          # --- 3. GHCR 强制转小写 ---
          OWNER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          TARGET_TAG=$(echo "$TARGET_TAG" | tr '[:upper:]' '[:lower:]')
          FULL_TARGET="${{ env.REGISTRY }}/$OWNER/$TARGET_TAG"

          echo "🎯 目标镜像地址: $FULL_TARGET"

          # --- 4. 智能摘要比对 ---
          NEED_SYNC=true
          if [ "$INPUT_FORCE" == "false" ]; then
             echo "🔍 检查 Digest & Created..."
             SRC_INFO=$(retry skopeo inspect $SKOPEO_FLAGS "docker://$SRC_IMAGE" --format='{{.Digest}}|{{.Created}}' 2>/dev/null || echo "")
             SRC_DIGEST=$(echo "$SRC_INFO" | cut -d'|' -f1)
             SRC_CREATED=$(echo "$SRC_INFO" | cut -d'|' -f2)
             
             DEST_INFO=$(retry skopeo inspect $SKOPEO_FLAGS "docker://$FULL_TARGET" --format='{{.Digest}}|{{.Created}}' 2>/dev/null || echo "")
             DEST_DIGEST=$(echo "$DEST_INFO" | cut -d'|' -f1)
             DEST_CREATED=$(echo "$DEST_INFO" | cut -d'|' -f2)
             
             if [ -n "$SRC_DIGEST" ]; then
                 if [ "$SRC_DIGEST" == "$DEST_DIGEST" ]; then
                    echo "✅ 摘要一致 ($SRC_DIGEST)，无需同步。"
                    NEED_SYNC=false
                 elif [ -n "$DEST_DIGEST" ] && [ "$SRC_CREATED" == "$DEST_CREATED" ]; then
                    echo "⚠️ 摘要不同但创建时间一致 ($SRC_CREATED)，判定为同源，跳过。"
                    NEED_SYNC=false
                 else
                     echo "🚀 需同步: $SRC_DIGEST vs $DEST_DIGEST"
                 fi
             else
                 echo "⚠️ 无法获取源摘要，跳过。"
                 NEED_SYNC=false
             fi
          fi

          # --- 5. 执行同步 ---
          if [ "$NEED_SYNC" == "true" ]; then
             echo "📥 拉取: $SRC_IMAGE"
             retry docker pull "$SRC_IMAGE" $PLATFORM_ARG

             echo "🏷️ 打标签: $FULL_TARGET"
             docker tag $SRC_IMAGE $FULL_TARGET

             echo "📤 推送: $FULL_TARGET"
             retry docker push "$FULL_TARGET"
             
             echo "🧹 清理..."
             docker rmi $SRC_IMAGE $FULL_TARGET || true

             echo "✅ 完成! docker pull $FULL_TARGET"
          fi

      - name: 发送 Webhook 通知
        if: always()
        run: |
          if [ -z "$WEBHOOK_URL" ]; then
            exit 0
          fi

          if [ "${{ job.status }}" == "success" ]; then
             TITLE="✅ GHCR 同步成功"
          else
             TITLE="❌ GHCR 同步失败"
          fi

          PAYLOAD=$(cat <<EOF
          {
            "msg_type": "text",
            "content": {
              "text": "$TITLE\n镜像: ${{ inputs.image_name }}\n状态: ${{ job.status }}\n链接: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            }
          }
          EOF
          )

          curl -H "Content-Type: application/json" -d "$PAYLOAD" "$WEBHOOK_URL" || true
